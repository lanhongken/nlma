Nonlinear Moving Average (nlma) Software
------------------------------------------

<a href="mailto:lanhongken@gmail.com">Hong Lan</a> 
and 
<a href="mailto:alexander.meyer-gohde@wiwi.hu-berlin.de">Alexander Meyer-Gohde</a></p>
March 14. 2014

**Summary**: This software computes the theoretical moments, impulse responses and simulations of the nonlinear moving average solution up to the third order. It also computes the moments using the simulated data generated by several other second and third order pruning algorithms.

1. Structure of the nlma Software 
-------------------------------------

The nlma software includes 4 main functions that can be called either separately or jointly

- `nlma_irf.m`: It computes nlma impulse reponses, and plots the results if `options_.nograph = 0`. This function calls

  - `pruning_abounds.m`: To compute nlma impulse responses. It calls
       
     - `return_dynare_version.m`: To check which version of Dynare is in use, ensuring required information will be loaded from correct locations
     
     - `full_block_dr_new.m`: If `options_.order = 3` and `options_.pruning = 0`, this will be invoked, and it seperates the risk correction of the first order coefficients from the first order coefficients themselves and seperates out the blocks of the third order policy function `ghxxx` etc.


- `nlma_simul.m`: It computes nlma simulations, and plots the results if `options_.nograph = 0`. This function calls

  - `pruning_abounds.m`: To compute nlma simulations. It calls

     - `return_dynare_version.m`
     
     - `full_block_dr_new.m`: If `options_.order = 3` and `options_.pruning = 0`.         


- `nlma_th_moments.m`: It computes nlma theoretical moments up to the third order, and calls

  - `full_block_dr_new.m`: If `options_.order = 3` and `options_.pruning = 0`

  - `nlma_th_mom_first.m`: To compute first order accurate theoretical moments

  - `nlma_th_mom_second.m`: To compute first and second order accurate theoretical moments. It calls

       - `nlma_th_mom_first.m`</p>

  - `nlma_th_mom_third.m`: To compute first, second and third order accrurate theoretical moments, and decomposes third order accurate theoretical variance into individual contribution from amplification and risk correction channel. It calls

     - `nlma_th_mom_second.m`: It calls

          - `nlma_th_mom_first.m`</p>

     - `disclyap_kron_3.m`: To solve some Sylvester equations if a model has more than 8 state variables. It calls
         - `@KronProd`: To compute Kronecker products.</p>  

- `simulated_moments.m`: It computes moments using simulated data (moments of simulated variables). The simulated data is generated by different pruning algorithms. It calls  

   - `pruning_abound.m`: To simulate the chosen pruning algorithm. It calls

       - `return_dynare_version.m`

       - `full_block_dr_new.m`: If `options_.pruning = 0` and `options_.order = 3`.
       

The remaining 2 functions are called by all the 4 main functions

  - `alt_kron.m`: To compute Kronecker products

  - `commutation_sparse.m`: To produce commutation matrix in sparse matrix form.                          


2. Installation and Usage
-------------------------

This software is so far in the form of matlab functions, and can be called after Dynare's stoch_simul command directly

- Make a copy of this software. In principle, it can be put anywhere, yet it is recommended to put the copy in Dynare's `contrib` folder, e.g.,

       `C:\dynare\4.4.2\contrib\nlma`

- Add the above path to matlab working path (assuming Dynare's matlab folder has already been added), e.g.,         

       `>> addpath C:\dynare\4.4.2\contrib\nlma`

- In a .mod file, call the desired nlma main function(s) after stoch_simul command, e.g.,

       `...`</br>
       
       `stoch_simul(order = 3);`</br>   
       
       `nlma_theoretical_moments = nlma_th_moments(M_,oo_,options_,var_list_);`</br>
       
       `nlma_irf = nlma_irf(M_,options_,var_list_);`

  This `.mod` file asks Dynare to solve the model to third order, and asks nlma to compute theoretical moments up to the third order. These moments will be saved to a structure array with the name `nlma_theoretical_moments` in matlab's workspace. Next, it asks nlma to compute and plot impulse responses up to the third order. The impulse response will be saved to a structure array with the name `nlma_irf` in matlab's workspace.
  
 - In recent versions of Dynare, higher order impulse responses are computed on the basis of repeated simulations, which may take a while when a model has many variables. The following example shows how to disable Dynare's impulse responses and compute nlma impulse responses of higher order only
       
       `...`</br>

       `stoch_simul(irf = 0, order = 3);`</br>
       
       `options_.irf = 40;`</br>        
       
       `nlma_irf = nlma_irf(M_,options_,var_list_);`

  This `.mod` file disables Dynare's impulse responses by setting `irf=0` in `stoch_simul` command. Then it sets `options_.irf=40;` that asks nlma to compute and plot third order accurate impulse responses out to 40 periods.</p>
  
It is worth noting that neither `nlma_irf.m` nor `nlma_simul.m` does joint plots. The impulse response, for example, of each and every variable, to each and every shock, is plotted separately, i.e., there would be `M_.endo_nbr*M_.exo_nbr` figures in total. It is recommended, for a model with many variables and shocks, to plot a subset of variables of interest at a time. To do this, just specify the subset of variables after `stoch_simul` command. This choice of variable will be passed to `nlma_irf.m` automatically. Take `example1.mod` in Dynare for example
  
        ...
     
        stoch_simul(irf = 0, order = 3) c k;
     
        options_.irf = 40;
     
        nlma_irf = nlma_irf(M_, options_,var_list_);
     
This plots the impulse responses of consumption and capital only.
  
  
3. New Features of this Version
-------------------------------

This version of nlma software uses the **RECURSIVE REPRESENTATION** of nonlinear moving average policy rule, which corresponds to Dynare's state space respresentation of policy rule. This means there is no need to compute the coefficients of nlma policy rule separately. Instead, all the coefficients can be recovered from those of Dynare's through the following mapping:

        Dynare                                        nlma

        ghx                    =                      ALPHA
   
        ghu                    =                      BETA_0
 
        ghxx                   =                      BETA_22

        ghxu                   =                      BETA_20

        ghuu                   =                      BETA_00

        ghxxx                  =                      BETA_333_1

        ghxxu                  =                      BETA_330_1

        ghxuu                  =                      BETA_300

        ghuuu                  =                      BETA_000

        ghs2                                          *See ghs2_nlma

        ghuss                                         *See ghuss_nlma

        ghxss                                         *See ghxss_nlma



 - `ghs2_nlma = [  ghx(1:nstatic,:)*ghs2_state_nlma+ghs2(1:nstatic,:)`</p>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; `ghs2_state_nlma`</p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`ghx(nstatic+npred+1:M_.endo_nbr,:)*ghs2_state_nlma+ghs2(nstatic+npred+1:M_.endo_nbr,:) ]`;</p>

 
    - `ghs2_state_nlma = (eye(npred)-ghx(nstatic+1:nstatic+npred,:))\(ghs2(nstatic+1:nstatic+npred,:));` </p>

 - `ghuss_nlma = ghuss + ghxu*alt_kron(ghs2_nlma(select_state,:),eye(ne));`

    - `ghuss_nlma` is called `BETA_Sigma_2_0` in early versions of nlma software.</p>

 - `ghxss_nlma = ghxss + ghxx*alt_kron(ghs2_nlma(select_state,:),eye(npred));`

    - `ghxss_nlma` is called `BETA_Sigma_2_1` in early versions of nlma software.

Indeed, this version directly recovers nlma coefficients from Dynare's solution, and use them to compute nlma theoretical moments, impulse responses and simulations.

4. Links
--------

- Early version of nlma software has two parts, the solution part and moments calculation part. The solution part computes nlma policy rules, impulse responses and simulations and can be downloaded [here](http://ideas.repec.org/c/dge/qmrbcd/192.html). The moments calculation part computes nlma theoretical moments and can be downloaded [here](http://ideas.repec.org/c/dge/qmrbcd/197.html).

- [Lan and Meyer-Gohde (2013a)](http://www.sciencedirect.com/science/article/pii/S0165188913001462) provides theoretical foundations and derivations of the nonlinear moving average approximation.

- [Lan and Meyer-Gohde (2013b)](http://ideas.repec.org/p/hum/wpaper/sfb649dp2013-024.html) provides the recurssive representation of nlma policy rule, and compares nlma with several other pruning algorithms.

- [Lan and Meyer-Gohde (2013c)](http://ideas.repec.org/p/hum/wpaper/sfb649dp2013-022.html) provides the derivation of nlma theoretical moments and variance decomposition.



